# In Depth Malware Analysis
## Deobfuscating Malicous JavaScript 
- First beautify the `js`
````
js-beautify loveyou.js > loveyou-beautify.js
````
- JavaScript can deobsfucate its portions during runtime, then supply the resulting scripts to function `eval` to execute them 
- Browser Specific JS can also use statements such as 
````
document.write
document.body.appendChild
document.parentNode.insertBefore
`````
- Always search for `eval` first 
- Execute the script so it deobsfucates itself as you observe it 
- Use standalone script interpreters `SpiderMonkey` on REMnux and `CScript` on Windows 
- If you are decoding a browser script, youll need to remove non js (HTML) components 
- Youll need to intercept functions like `eval` and define the missing objects that would have been supplied by the OS or the app
````
js -f loveyou.js #get error ActiveXObjects is not definied
````
- **REMnux includes some definitions in `/usr/share/remnux/objects.js`**
- Specify it as the first `-f` parameter in `SpiderMonkey` 
- Use this as a starting point 
- Modify it based on the needs of the speciment 
- Tweak a copy of the file so you dont break the origional 
- **Supply `objects.js` as the first parameter to deobsfucate `loveyou.js`**
- `js -f /usr/share/remnux/objects.js -f loveyou.js > loveyou-out.js`
- `more loveyou-out.js`
### Alternative 
- **Run the script on Windows using CScript to monitor its activities via AMSI**
````
powershell 
logman start AMSITrace -p Microsoft-AntiMalware-Scan-Interface Event1 -o AMSITrace.etl -ets 
script loveyou.js
logman stop AMSITrace -ets 
AMSIScriptContentRetrieval > loveyou-out.txt 
````
### Alternative 2
- Add the new definition to the type of `loveyou.js`
- Use `WScript.Echo` in `CScript` instead of `print` in `SpiderMonkey` 
- If you just want to see the deobsfucated script without executing it, delete the lines that contain `origional_eval`
````
origional_eval = eval;
eval = function(input_string) {
  WScript.Echo(input_string);
  origional_eval(input_string)
  }
````
- Now add this code to the top of the malicious script using `Notepad++` then save
### Another Example 
- Use `SpiderMonkey` to deobfuscate `fgg.js`
````
unzip fgg.zip
js -f fgg.js #error
code fgg.js
js -f /usr/share/remnux/objects.js -f fgg.js
````
- Take not the error is `location is not definied`
- When you open the script you see `location.href` 
- Could that be the debosfucation key?
- When saving suspicious web pages capture the URLs and headers in case deobsfucation needs them 
- in `fgg.js` the url used as a call out was `http://gitporg.com/cgi-bin/index.cgi?fgg
- To deobsfucate `fgg.js` copy objects.js and then adjust `location.href` to specify the expected value 
- Adjust This:
````
location = {
  href:"http://www.example.com/page"
 }
 TO:
 location = {
  href:"http://gitporg.com/cgi-bin/index.cgi?fgg"
 }
 ````
 - Supply the edited file when executing `fgg.js` in `SpiderMonkey` then examine the output 
 - The deobsfucated script reveals a URL that we couldnt see in the origional script 
 ### Additional Considerations for deobsfucating JS
 - Be carful modifying brower scripts if they call `arguments.callee` because this allows the function to examine its own body 
 - Example: `var M1FDAB=arguments.callee.toString()`
 - You can use the debuggers built into webbrowsers to deobsfucate browser scripts as they run 
 - For JS designed to run outside the browser try `box-js`
 - If you encounter scripts for PDF files extract them then deobsfucate them with `SpiderMonkey` 
 ## Recognizing Packed Malware 
 - Malware authors can protect their creations by packing them 
 - Packers are tools that compress, obsfucate, encrypt, or otherwise encode the origional code
 - the packed program decodes the code into memory when it runs 
 - This safeguards the speciment form static analysis techniques 
 - Packed programs are also difficult to dissassemble and or debug 
 - Not all malware is packed 
 - The unpacking code extracts the origional program to memory and runs the program from memory 
 ````
                     ---Pack-->                           ---Run-->
 Origional program                Unpacking code                      Unpacked program 
 stored on its                    --------------                      stored in memory 
 authors file system              Packed program stored               of the infected 
                                  as data                             filesystem
````
- **Packers conceal the origional code and can hide some PE header values to further complicate analysis**
- **Sections:** Regions of code or data the comprise the executable file which will be loaded into memory 
- **The entry point:** Address of the first instruction in the program (officially called AddressOfEntryPoint)
- **Import Address Table IAT:** Pointers to funcation in external DLLs (That is API calls)
- Packers differ in techniques, sophistication, and the protection they provide 
## Types of Packers 
- We will start with `UPX` which is free and common, simple to unpack 
- It has built in unpacking capabilities 
- However it can be scrambled to complicate unpacking 
- Numerous other packers exist, they tend to be more complex than UPX
- Other packers:
````
Armadillio, FSG, Themida
Some use custom private packers
````
- Most packers do not include built in unpacking capabilities 
## Basic Unpacking 
- If possible try to identify the packer, research it and look for unpacking tips 
- You can tell that the exeutable might be packed if:
````
The file contains very few readable strings
Byte values in the file or some of its sections are too random (high entropy)
The file has few imports or recognizable funcation 
The embedded strings sometimes reveal the name of the packer
````

