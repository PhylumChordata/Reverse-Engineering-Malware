# 534f62e75abcbb088a215f58a4a90edd734e77cdbea3029c53ffa1306708f61c
## Overview 
- Script is written in bash to connect back to a botnet C2 server via the IRC protocol
- This script is the most advanced bash script captured by the cowrie Dshield honeypot at the time of of writing 8/1/22.
- This highlights threat actors move away from commonly known protocols (HTTP/HTTPS/DNS) to more niche edge case protocols that an enterprise might not be monitoring (or even be aware of).
- Many organizations rely on solutions such as  `squid proxy` to provide insight into HTTPS traffic leaving their enterprise, without packet capture running via `tcpdump` on public facing Unix devices, this C2 traffic could easily be missed.

## Lines 4-6 
- Setting of custom enviromental variables 
````
MYSELF=`realpath $0`
DEBUG=/dev/null
echo $MYSELF >> $DEBUG
````
- `realpath $0` simply will print the directory (without the script name) that it is running from.
- i.e. if the path is `/home/user/Desktop/mal.sh` entering `realpath $0` would return `/home/user/Desktop`
- Line 5 is pretty self explanitory 
- Line 6 the script will then set the `DEBUG` variable to the value of the `realpath $0` which is where the script is running from
## Line 8 
- The script then checks if it is running as root
- If it is:
- Line 10 sets new variable caled `NEWMYSELF` and sets the value equal to `mktemp -u 'XXXXXXXX'`
- `mktemp -u 'XXXXXXXX'` does not make a new directory it will print a random string of upper + lower case letters with the amount of `XXX` denoting the char count
- Thus `NEWMYSELF` will be set to a random string each time the script is run making it difficult to utilize this as an IOC
- The script (line 11) will then copy itself into `/opt/result-of-mktemp-cmd`.  As the `opt` part is hard coded this can form as a fantastic IOC.
- The next three lines are the scripts persistance mechanism.  It will add itself to `rc.local` allowing it to survive a reboot, and execute everytime on start up 
- It will then reboot the device (line 16)
- If its not running as root:
- It will set the variable `TMP1` to the value of `mktemp` 
- It will then echo the value of `mktemp` into `$DEBUG` overwriting the value of `dev/shm` which it was previously set to 
- It will then stop all instances of 
````
bins.sh, minerd, node, nodejs, ktx-armv4l, ktx-i586, ktx-m68k, ktx-mips, ktx-mipsel, ktx-powerpc, ktx-sh4, ktx-sparc, arm5, zmap, kaiten, perl
````
- It will then add `"127.0.0.1 bins.deutschland-zahlung.eu"` to the `/etc/hosts` file preventing the device from being able to access any of its internal services.
- This can also act as a fantastic IOC as this URL is hardcoded into the script.
- It will then delete (lines 38, 39) the `.bashrc` for the `root` and `pi` user.  This script appears to be specifically targeting raspberry pi devices
- In addition it will change the password to the `pi` user and set it to `$6$vGkGPKUr$heqvOhUzvbQ66Nb0JGCijh/81sG1WACcZgzPn8A0Wn58hHXWqy5yOgTlYJEbOjhkHD0MRsAkfJgjU/ioCYDeR1`
- It will add the `/root/.ssh` directory if it already does not exist and append a public key to the `authorized_keys` file adding another layer of persistance.
- Finally it will add `8.8.8.8` to the `etc/resolve.conf` simply adding `Google DNS` to the devices DNS server pool
### Deleting Things 
- Line (47) it will delete all tmp files associated with the `ktx*` processes that we say it attempting to stop earlier in the script
- It also deletes all tmp files associated with the `cpuminer` and `kaiten` process that we also say it attempting to kill if they were running

### Here doc
- It will echo a public key into `tmp/public.pem` (another great IOC) utilizing a `Here Doc` method which is annotated by its use of `<<EOFMARKER`
- It can be assumed that this public key can be used to reach out to `127.0.0.1 bins.deutschland-zahlung.eu` as from OSINT you cannot access that domain without the proper key
## Make the name for the bot 
- It will then use another `mktemp` command to generate a random name for the bot that it will then chack back in ith 
### Exfil survey data
- It not focuses on its initial survey to report back to the c2, and it does so in a curious way.
- It will get the first parameter for the `uname -a` command which will almost always be `Linux` it will then `md5sum` that returned value.
- It then sets the variable `NICK` equal to `a${SYS:24}` which prints `a`, so `NICK=a`
- It will begin its `while true` loop with 6 listed C2 domains
````
  arr[0]="ix1.undernet.org"
	arr[1]="ix2.undernet.org"
	arr[2]="Ashburn.Va.Us.UnderNet.org"
	arr[3]="Bucharest.RO.EU.Undernet.Org"
	arr[4]="Budapest.HU.EU.UnderNet.org"
	arr[5]="Chicago.IL.US.Undernet.org"
````
- It will pick one to connect back to at random denoted by line 76 `rand=$[RANDOM % 6]
- it will then set the server address for the C2 to one of those names via line 77 `svr=${arr[$rand]}` --> it will utilize this `svr` variable shortly
- It will then connect back on port `6667` to its chosen domain as seen in the `eval` statement (line 79)
## if statement check 
- After executing that `eval` (connect to c2) command it will then check the exit status and if it is equal to "0" (successful)
- If the command is sucsessful it will continue if it is not it will `echo $NICK` which was previously set to `a`.
- It will then execute `eval 'printf "NICK $NICK\r\n" >&3;'` which normally would return `Bad file descriptor error` 
- However due to the `eval` command on line 79 it will open a remote connection to the C2 server.  The connection will be visible in the `netstat` output, however it will not open a reverse shell it will simply connect to the C2.  
- At this time the C2 would not have a shell on its port `6667` it is simply testing its connection ability by sending `NICK a` back to the C2
- If that connect back where it prints `NICK a` is successful it will continue onward with the script, if it is not successful it will attempt to execute:
````
eval 'printf "USER user 8 * :IRC hi\r\n" >&3;'
````
- This command due to the initial connect back see again on line 79 will post back to the C2 server `USER user 8 * :IRC hi`
- This would confirm with the c2 server that a victim is on the hook and due to the message being `hi` it wouldnt particularly look malicious.
## Main Loop
- This main loop starts on line 95 and is the heart of this program, it utilizes another `while true` loop making this run until the script is killed or the box is rebooted (it will restart to the `rc.local` persistance set up earlier)
- It will constantly be attempting to `"read msg_in` (from the C2 server) (line 97)
- If it does successfully read the message in (checked by if statement line 99) it will break out of the if statement and jump to the next one
- In other words it will lay dormient and continue to try and `read msg_in` when it does it will jump down to line 103
- On line 103 it will attempt to evaluate if the message in is equal to `"PING"`
- 

- 
