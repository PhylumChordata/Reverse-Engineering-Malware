# Reversing Malicious Code
- **Goal is to understand common malware characteristics at a code level**
- May include potential branches of execution with code analysis 

- **Overview of the code lifecycle**
- Source code is translated into object code by a compiler
- Object code is then combined with librries and an executable file is created
- To run the file, the operating system reads various information from the executable file, allocates memory, and loads required libraries into memory
- Control is transfered to the code to execute
- At this final stage is where we examine the code with a debugger
- Note: Libraries may be loaded during the programs execution 

## Ghidra 
- Developed by NSA
- Its decompiler produces a C representation of the code to speed up analysis 
- Includes support for writing java and python scripts to automate analysis 
- Help is accessed via F1 key 
- Ghidra v10 includes a debugger
- https://for610.com/ghidra
#### Create a new project 
- `File --> New Project`
- Choose the project type 
- Click `Finish`
- Drag and drop the speciment into the project window
- Accept defaults in the `Imports` windows and click Ok
#### Launch the code browser and being the auto-analysis 
- Make sure to enable `WindowsPE x86 Propagate Exernal Parameters` option
- Finally click the Analyze button and wait for Ghidra to finish 
- Once auto analysis is compled an Auto Analysis summary will show any warnings or issues encountered during the rocess 
- A common warning is that the file does not `contain debug information` 
- This is common and not an issue 

#### Before Proceeding save the project and take a snapshot 
### Ghidra Overview 
- Main window is the `Listing View` which presents the target programs coe and data 
- Will initially bring you to the beginning of the file in the `Listing View` --> notice the `MZ` string
- If you scroll down from there you can examine the programs header

#### Program Tree 
- Window is in the top left and shows the different sections and headers 
- Section names are typically:
````
.text - Contains executable code
.rdata - Contains read-only data
.data - Contains data 
.reloc - Contains relocation data to fix up addresses in the file if it is not loaded at the prefered address
````
- To jump to the `.text` section double click the `.text` node 
- https://for610.com/peformat

- **FUN in Ghidra**
- In Ghidra the `FUN_` prefix generically refers to a function while the numeric value refers to the address where the function is loaded into memory
- Origional name of the function is normally lost during compilation 
- Execution occurs linearly one instruction after the next
- On the far left you will have a 32 bit address such as `00401007` (hex) 
- This affress represents the location of code in memory after the program is loded, not the address of a location on disk i.e. within a file hex editor 
- On the right there are x86 assembly instructions 
- **Note:** - This is the beginning of the `.text` section, not the beginning of the program, that occurs at the entry point 

#### Function graph view provides a visul perspective on code
- Click on the function you want i.e. `FUN_00401007`
- Browse to `Window --> Function Graph` menu item 
- Helpful for visualizing loops and complex conditionals within a function but the `Listing view` is more compact nd easier for some people to navigate 
- **The color of the arrows symbolize code flow**
- If the code block ends in a conditionl jump green arrows indicate the pth here execution will continue if the condition is met
- If the condition is not met a red arrow will show where execution continues 
- If the arrow is blue the clode ends in an unconditionl jump

- **View Imports to review a programs external dependencies**
- The import address table (IAT) helps direct code analysisi 
- You can view imports in the Symbol Tree window but we will access this information via `Window --> Symbol References`
- Filter symbols by "`Imported`" to focus on dependencies 

- **Look for API call patterns associated with malware behavior**
- We can examine imports to identify potential functionality associated with common malware characteristics 

- **Learn more about an API call at microsoft.com**
- Types of API Calls:
````
A --> (ANSI)
W --> (Wide)
Ex --> (Extended)
````
- Refers to if the function supports ANSI (8 bit character)
- Wide refers to a two byte character representation (UTF-16)
- Extended is when MSFT updates a function and the new function is not compatable with the old one

- **Instructions reference registers, immediate values and memory**
- Instructions have two components: `operation and operand`
- Instructions can have 0-3 operands 
- An Operand can be:
````
A register
A memory location 
An immediate value e.g. 0x6453)
````
- Consider `MOV EAX, 0x6453`
- EAX is the destination (first)
- 0x6453 is the source (second)
- You are setting EAX to the value 0x6453
- Operands may be implied 

**Intel processor uses registers to track the state of computation as instructions are executed**
- Registers are on chip memory locations 
- Instructions act on registers and memory locations 
- A CPU has a series of registers 
````
Some registers are general purpose
Some have a particular use
Some are both
````
- We monitor registers to track arguments, variables, and function return values 
- **The x86 arhitecture uses the following general purpose registers to hold code and data**
````
EAX --> Used for addition, multiplication, and return values
ECX --> Used as a counter 
EBP --> Used to reference arguments and local variables
ESP --> Points to the last item on the stack 
ESI/EDI --> Used by memory to transfer instructions 
````
- **Special use registers hold flags and track program execution**
- `EIP` points to the next instruction to execute 
- `EFLAGS` bit represents the outcome of computers and they control CPU operations
- **Segment registers include:**
````
CS - Code segment
DS - Data segment 
SS - Stack segment 
````
- **32 bit registers can also be accessed as 16 and 8 bit registers**
- On 32 bit arch, registers can be accessed by their default `dword` size
- To access a registers lower `16 bits` the leading `E` is omitted from the name e.g. `EAX` becomes `AX` 
- **The naming scheme for `EAX EBX ECX EDX` is as followed**
- `E<letter>X` --> `dword` 32 bit value of the register 
- `<letter>X` --> lower word 16 bit value of the register 
- `<letter>H` --> high byte 8 bit of the `<letter>X` value of the register 
- `<letter>L` --> low byte 8 bit of the `letterX>` value of the register 
````
EAX means 32 bits 
AX means the low 16 bit value 
AH means the high 8 bytes of AX 
AL means the low 8 bits of AX
````
- **The length of a word, dword, and qword are 16, 32, and 64 bits**
- A `word` in assembly is the natural size for a unit of data 
- `16 bit` processor has `16-bit` words
- Many tools consider a word to be 16 bits regardless of processor size 
- Additional common data sizes:
````
8 bits --> 1 byte 
32 bits --> dword 
64 bits --> qword
````
- **The operand for one push instruction is a pointer to a string**
- A `pointer` is a variable that holds a memory address (it points to a memory location)
- When the address that the pointer points to is accessed it is called dereferncing because the pointer references another location in memory 
- Pointers are more efficient, rather than copying around a data structure in memory its more efficient to copy the value of a pointer (4 bytes on 32 bit systems)
- A `PUSH` instruction before a `CALL` often represents arguments passed to the function specified by the `CALL`

- **Memory can be accessed directly by many assembly instructions**
- Example:
````
MOV EAX, [0x410230]
````
- Brackets mean fetch data at the specified address (dereference)
- This is direct addressing because we are dereferencing an immediate value
- The result is that 4 bytes of data at 0x410230 will be moved to `EAX`
- Some tools like `IDA` omit brackets for direct addresses (`IDA: dword_410230`)
- **Memory may also be addressed by reference indirectly**
- The address may be calculated or in a register 
- This is called an `Effective Address` and it enables us to work efficiently with data structures 
- Format: `Base + (Index * Scale) + Displacement 
````
BASE        Index   Scale       Displacement
(EAX EBX) + (EAX EBX  1)   +     (None)
(ECX EDX) + (ECX EDX  2)   +     (8 bit value)
(ESP EBP) + (EBP ESI  4)   +     (16 bit value)
(ESI EDI) + (EDI      8)   +     (32 bit value)
`````
- **Indirect Referencing:** address of the destination is calculated or it resides in a register. The calculated address is called the effective address (EA) 
- If the address sits in a register, it is still different from direct memory addressing where the register is the destination
- In indirect memory addressing the register holds the address of the destination.
- Large advantage of indirect memory addressing is the capability to efficiently work with data structures
- You can increment the value of a signle register to step through fields of a data structure or the same field of an array of data structures
- If the scale is used and index register must also be used

- **Examples of indirectly addressing memory**
- `[EAX]` : Access dynamically allocated memory (base)
- `[EBP + 0x10]` : Access data on the stack (base + displacement)
- `[EAX + EBX * 8]` : Access an array with 8-byte structure ( base + index * scale)
- `EAX +EBX + 0xC]` : Access fields of a two dimensional array of structures (base + index + displacement)
- Indirect memory addressing may pose challenges for static code analysis because registers are not populated until runtime
- **Strings are an example of a data structure**
- Data structures groups simple varibales into more complex types 
- Examples of data structures include: strings, linked lists, sockets, and hile handles
- When reversing determine the type of data structure by usage
- Data strutures enable 


















































































